#!/usr/bin/perl

use strict;
use warnings;
use Net::GPSD3;
use Term::ReadKey;
use File::Slurp;
use Term::ANSIColor;
use IPC::System::Simple qw(system);

##############################################################################

# WARNING: Do not run in unsafe mode unless you have explicit permission to be
#          testing the WAPs in the surrounding area!

##############################################################################


# Convenience subs
sub Die {
    my ($message) = shift;
    print color('red'), "$message\n", color('reset');
    exit 1;
}

sub Notice {
    my ($message) = shift;
    print color('yellow'), "$message\n", color('reset');
}

sub Failure {
    my ($message) = shift;
    print color('red'), "$message\n", color('reset');
}

sub extract_settings_from_config {
    # TODO: Parse config file for mode, adapter information? 
}

# Config
if (@ARGV != 1) {
    Die("Usage: justDrive [safe|unsafe]");
}
my $mode = $ARGV[0];
# my $mode = extract_settings_from_config();
chomp($mode);
if ($mode eq '--help' || $mode eq '-h') {
    print <<'END_HELP';
Usage: justDrive [safe|unsafe]

Arguments:

    safe            ->      Collect basic information from networks in the surrounding area (GPS coordinates, ESSID, BSSID, Password Protected?)

    unsafe          ->      Collects the same data as 'safe' mode but also tries to capture the password hash to store

Options:

    -h, --help      ->      Displays the help menu

END_HELP
    exit;
}
unless ($mode eq 'safe' || $mode eq 'unsafe') {
    Die("Invalid argument : $mode. Expected 'safe' or 'unsafe'.");
}
if ($mode eq 'unsafe') {
    if ($> != 0) {
        Die("This program must be run as root!");
    }
    print "Running this program in 'unsafe' mode may be viewed as unethical or even illegal without explicit permission.\nIf you understand the risks and want to continue anyway, enter 'Y': ";
    chomp(my $will_continue = <STDIN>);
    unless ($will_continue =~ /[yY]$/) {
        Die("Failed to accept the risks of unsafe mode.");
    }
}

# Teach the user how to pull up help menu while in app
print "\nWelcome to justDrive. Press '?' to learn the commands of this app.\n\n";
# my $interface = $ENV{'wAdapt'}; # Make sure this environment variable is set on your system! (Or just hardcode it in if you're one of THOSE people)
my $interface = 'wlo1'; # Used for testing without network adapter
print "Do you want to use a persistent or temporary log? (p/t): ";
chomp(my $choice = <STDIN>);
my $tmpLog = "/tmp/justDriveLog.txt";
my $persLog = "../data/justDriveLog.txt";
my $output_file;
if ($choice eq 'p') {
    $output_file = "$persLog";
} elsif ($choice eq 't') {
    $output_file = "$tmpLog";
} else {
    Die("Invalid choice. Enter 'p' for persistent or 't' for temporary.");
}
my $cap_dir = "../data/Captures"; 
my $scan_interval = $mode eq 'safe' ? 15 : 45;
my $startFrontend = 0;

# Init GPS
# Make this a check as to whether the service is even running
my $gps = Net::GPSD3->new;
Notice("Warning: Cannot connect to GPSD") unless $gps->poll;

# Get GPS coordinates
sub get_gps_coords {
    my $lat;
    my $lon;
    my $fix = $gps->poll->fix;
    unless ($fix) {
        Notice("Warning: No GPS fix available");
    } else {
        $lat = $fix->lat;
        $lon = $fix->lon;
    }
    unless (defined $lat && defined $lon) {
        Notice("Warning: GPS coordinates not defined");
    } else {
        print "GPS: $lat, $lon";
    }
    return ($lat, $lon);
}

# Scan for networks
sub scan_networks {
    my $cmd = "iwlist $interface scan";
    my @list = `$cmd 2>&1`;
    my $exit_status = $? >> 8;
    if ($exit_status != 0) {
        Failure("Failed to scan for networks");
        undef @list;
    }
    return @list;
}

# Capture handshake
sub capture_handshake {
    my $ssid = shift;
    my $bssid = shift;
    my $name = shift;
    # TODO: Make this actually work (Handle output of commands)
    my $capture_file = "$cap_dir/$name.cap";
    # system("airodump-ng --bssid $bssid -c 6 -w $capture_file $interface") == 0 or Die("Failed to start airodump-ng: $!");
    # system("aireplay-ng --deauth 10 -a $bssid $interface") == 0 or Die("Failed to deauthenticate clients: $!");
    return $capture_file;
}

# Extract data from output
sub extract_info {
    my @data = shift;
    my @info;
    my ($bssid, $essid);
    foreach my $line (@data) {
        chomp($line);
        if (!$bssid && $line =~ /Address:\s+([0-9A-Fa-f:]{17})\b/) {
            $bssid = $1;
            next;
        }
        if (!$essid && $line =~ /^\s*ESSID:"([^"]+)"/) {
            $essid = $1;
        }
        if (defined $bssid && defined $essid) {
            my $name_for_file = $essid;
            $name_for_file =~ s/ /_/g;
            # Check for duplicate ESSID and BSSID
            if (!is_dupe_ssid($name_for_file, $essid, $bssid, @info)) {
                my $capture_file;
                if ($mode eq 'safe') {
                    $capture_file = "$cap_dir/$name_for_file.cap";
                } else {
                    $capture_file = capture_handshake($essid, $bssid, $name_for_file);
                }
                push @info, ($essid, $bssid, $capture_file);
            }
            undef $bssid;
            undef $essid;
        }
    }
    return @info;
}

# Check if duplicate ESSID or BSSID exists in existing records 
sub is_dupe_ssid {
    my ($name, $ssid, $mac, @data) = @_;
    for (my $i = 0; $i < @data; $i += 3) {
        if ($data[$i] eq $ssid || $data[$i+1] eq $mac) {
            return 1;
        }
    }
    open my $fh, '<', $output_file or Die("Could not open \"$output_file\": $!");
    while (my $line = <$fh>) {
        chomp $line;
        if (index($line, $ssid) != -1 || index($line, $mac) != -1) {
            close $fh;
            return 1;
        }
    }
    close $fh;
    if (-e "$cap_dir/$name.cap") {
        return 1;
    }
    return 0;
}

# Log data
sub log_data {
    if (@_ == 4) {
        # [ err, essid, mac, file ]
        my ($err, $ssid, $mac, $file) = @_;
        my $log_entry = "[\"$err\", \"$ssid\", \"$mac\", \"$file\"]\n";
        print "$log_entry";
        write_file($output_file, {append => 1}, $log_entry);
    } else {
        # [ lat, lon, essid, mac, file ]
        my ($lat, $lon, $ssid, $mac, $file) = @_;
        my $log_entry = "[\"$lat, $lon\", \"$ssid\", \"$mac\", \"$file\"]\n";
        write_file($output_file, {append => 1}, $log_entry);
    }
}

sub file_has_data {
    my ($file) = shift;
    my $check = `stat $file | awk '/Size:/ {print \$2}'`;
    if ($check <= 0) {
        return 0;
    }
    return 1;
}

sub spoof_mac_address {
    # TODO: Implement this
    print "Generating a spoofed MAC address...";
}

# Main loop
unless (-e $output_file) {
    open my $create_file, '>', $output_file or Die("Cannot create log file: $!");
    close $create_file;
}
unless (-d $cap_dir) {
    eval {
        make_path($cap_dir) or Die("Cannot create directory for capture files: $!"); 
    }
}
if ($mode eq 'safe') {
    print color('green'), "Running in safe mode.\n", color('reset');
} else {
    print color('red'), "Running in unsafe mode.\n", color('reset');
    spoof_mac_address();
}
print color('blue'), "--------------------------------\n", color('reset');
print color('blue'), "Press SPACE to start scanning...\n", color('reset');
print color('blue'), "--------------------------------\n", color('reset');
while (1) {
    ReadMode 'cbreak';
    my $key = ReadKey(0);
    if (defined $key && $key eq ' ') {
        print color('green'), "\nScanning has been started...\n", color('reset');
        my $iter = 1;
        while (1) {
            $key = ReadKey(-1);
            if (defined $key && $key eq ' ') {
                print color('yellow'), "\nScanning has been stopped: ", color('reset'), "(press Space to resume or q to quit)...\n";
                last;
            }
            print color('blue'), "\nRound: $iter\n", color('reset');
            print "Getting GPS coordinates\n";
            my ($lat, $lon) = get_gps_coords(); # Change this to calculate the coords of the networks you try to connect to
            print "Scanning for networks...\n";
            my @networks = scan_networks();
            if (@networks) {
                print "Extracting info from networks...\n";
                my @info = extract_info(@networks);
                my $net_count = (scalar @info) / 3;
                print "$net_count new networks found\n";
                if ($net_count != 0) {
                    print "Logging data from networks...\n";
                    for (my $i = 0; $i < @info; $i += 3) {
                        unless (defined $lat && defined $lon) {
                            log_data("GPS Unavailable", $info[$i], $info[$i+1], $info[$i+2]);
                        } else {
                            log_data($lat, $lon, $info[$i], $info[$i+1], $info[$i+2]);
                        }
                    }
                } else {
                    print "No new data to log.\n";
                }
            } else {
                Failure("Unable to scan for networks, waiting until next cycle to scan...");
            }
            sleep $scan_interval;
            $iter++;
        }
    } elsif (defined $key && $key eq 'h' && !$startFrontend) {
        my $url = "http://localhost:8080";
        my $endpoint = "http://localhost:8080/heatmap-data";
        print "Heat map generation coming soon.\n";
        my $tmpLogExists = -e "$tmpLog" ? 1 : 0;
        my $persLogExists = -e "$persLog" ? 1 : 0;
        if ($tmpLogExists) {
            print "Log file found at $tmpLog\n";
        }
        if ($persLogExists) {
            print "Log file found at $persLog\n";
        }
        my @files;
        if ($tmpLogExists && $persLogExists) {
            print "Which of the log files would you like to use for the heat map?\n't' for tmp\n'p' for persistent\n'b' for both\nChoose: ";
            chomp(my $choice = <STDIN>);
            if ($choice eq 'b') {
                unless (file_has_data($tmpLog)) {
                    Die("There is no data in the temporary log. Time to go driving!");
                }
                unless (file_has_data($persLog)) {
                    Die("There is no data in the persistent log. Time to go driving!");
                }
                push @files, ("$tmpLog", "$persLog");
            } elsif ($choice eq 'p') {
                unless (file_has_data($persLog)) {
                    Die("There is no data in the persistent log. Time to go driving!");
                }
                push @files, ("$persLog");
            } elsif ($choice eq 't') {
                unless (file_has_data($tmpLog)) {
                    Die("There is no data in the temporary log. Time to go driving!");
                }
                push @files, ("$tmpLog");
            } else {
                Die("Invalid choice. Must choose 't', 'p', or 'b'.");
            }
        } elsif ($persLogExists) {
            unless (file_has_data($persLog)) {
                Die("There is no data in the persistent log. Time to go driving!");
            }
            push @files, ("$persLog");
        } elsif ($tmpLogExists) {
            unless (file_has_data($tmpLog)) {
                Die("There is no data in the temporary log. Time to go driving!");
            }
            push @files, ("$tmpLog");
        } else {
            Die("There are no existing log files to use for heat map generation...");
        }
        my @data;
        foreach my $file (@files) {
            open my $fh, '<', $file or Die("Cannot open file $file: $!");
            while (my $line = <$fh>) {
                chomp($line);
                push @data, $line;
            }
            close $fh;
        }
        my $json = encode_json(\@data);
        my $http = HTTP::Tiny->new;
        my $response = $http->post(
            $endpoint,
            {
                headers => {'Content-Type' => 'application/json'},
                content => $json,
            }
        );
        if ($response->{success}) {
            print "Heatmap data has been sent to the web page.";
        } else {
            Failure("Failed to post data to $endpoint: $response->{status} $response->{reason}");
        }
        print "To access the heat map visit http://localhost:8080";
    } elsif (defined $key && $key eq '?') {
        print <<'END_SCRIPT_HELP';

########################################### HELP MENU #########################################################
If the program is in the middle of a scan, the motions will not be executed until it finishes!

Motions:
    Space   ->      Start or stop the script (If pressed during a round, it will pause once the round finishes)
    h       ->      Generate a heat map from the collected data
    ?       ->      Display help menu
    q       ->      Quit the program
###############################################################################################################
END_SCRIPT_HELP
    }
    last if defined $key && $key eq 'q';
}
ReadMode 'normal';
print "Exiting...\n";
